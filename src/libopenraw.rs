//! Safe wrapper around the libopenraw FFI.
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

use std::{
    convert::TryInto,
    ffi::{CString, OsStr},
    fmt,
    io::Cursor,
    os::unix::ffi::OsStrExt,
    path::Path,
};

use anyhow::{bail, Result};

/// Raw FFI bindings generated by bindgen.
#[allow(dead_code)]
pub mod ffi {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// A libopenraw `RawFile`.
pub struct RawFile(ffi::ORRawFileRef);

impl Drop for RawFile {
    /// Drop rawfile memory through FFI on drop.
    fn drop(&mut self) {
        let err = unsafe { ffi::or_rawfile_release(self.0) };
        if err != ffi::or_error::OR_ERROR_NONE {
            eprintln!("Warning: Could not free RawFile memory: {}", err);
        }
    }
}

impl RawFile {
    /// Create a new `Rawfile` with type unknown from the specified path.
    ///
    /// Note: Just because this returns a successful result, does not mean that
    /// the path is valid. If the path is invalid, then operations on the
    /// `Rawfile` will fail.
    pub fn new(path: impl AsRef<Path>) -> Result<Self> {
        // Note: Converting an path to bytes only works correctly on Posix systems,
        // but not on Windows (because Windows uses a different path encoding).
        // Since libopenraw does not support Windows either so far, we can ignore
        // this for now. See https://internals.rust-lang.org/t/pathbuf-to-cstring/12560
        // for details.
        let input_path_os_str: &OsStr = path.as_ref().as_ref();
        let input_path = CString::new(input_path_os_str.as_bytes()).unwrap();
        let rawfile = unsafe {
            ffi::or_rawfile_new(
                input_path.as_ptr(),
                ffi::or_rawfile_type::OR_RAWFILE_TYPE_UNKNOWN,
            )
        };
        if rawfile.is_null() {
            bail!("Could not create RawFile");
        }
        Ok(Self(rawfile))
    }

    /// Return a thumbnail with approximately the specified `preferred_size`.
    pub fn get_thumbnail(&self, preferred_size: u32) -> Result<Thumbnail> {
        let thumbnail = Thumbnail::new()?;
        let err = unsafe { ffi::or_rawfile_get_thumbnail(self.0, preferred_size, thumbnail.0) };
        if err != ffi::or_error::OR_ERROR_NONE {
            // TODO: Parse error code into enum
            bail!("Extracting thumbnail data failed with error code {}", err);
        }
        Ok(thumbnail)
    }

    /// Return the image orientation (using EXIF semantics).
    ///
    /// If there is no orientation attribute, 0 is returned.
    pub fn get_orientation(&self) -> i32 {
        unsafe { ffi::or_rawfile_get_orientation(self.0) }
    }
}

/// A libopenraw `Thumbnail`.
pub struct Thumbnail(ffi::ORThumbnailRef);

impl Drop for Thumbnail {
    /// Drop thumbnail memory through FFI on drop.
    fn drop(&mut self) {
        let err = unsafe { ffi::or_thumbnail_release(self.0) };
        if err != ffi::or_error::OR_ERROR_NONE {
            eprintln!("Warning: Could not free Thumbnail memory: {}", err);
        }
    }
}

impl Thumbnail {
    /// Create a new `Thumbnail`.
    ///
    /// This will return an error if `or_thumbnail_new` returns a null pointer.
    pub fn new() -> Result<Self> {
        let thumbnail = unsafe { ffi::or_thumbnail_new() };
        if thumbnail.is_null() {
            bail!("Could not create Thumbnail");
        }
        Ok(Self(thumbnail))
    }

    /// Determine and return the thumbnail image data format.
    pub fn get_format(&self) -> DataType {
        let dt_raw = unsafe { ffi::or_thumbnail_format(self.0) };
        dt_raw.into()
    }

    /// Return the data size of the thumbnail.
    pub fn get_data_size(&self) -> ffi::size_t {
        unsafe { ffi::or_thumbnail_data_size(self.0) }
    }

    /// Return a slice to the thumbnail data.
    pub fn get_data(&self) -> &[u8] {
        let buf_size = self.get_data_size();
        unsafe {
            std::slice::from_raw_parts(
                ffi::or_thumbnail_data(self.0) as *const u8,
                buf_size.try_into().unwrap(),
            )
        }
    }

    /// Convert this thumbnail to an image-rs `DynamicImage`.
    pub fn to_image(&self, _orientation: i32) -> Result<image::DynamicImage> {
        // Extract raw thumbnail data
        let data = self.get_data();

        // Convert depending on format
        let format = self.get_format();
        Ok(match format {
            DataType::Jpeg | DataType::Png | DataType::Tiff => {
                let mut reader = image::io::Reader::new(Cursor::new(data));
                reader.set_format(format.try_into()?);
                reader.decode()?
            }
            _ => bail!("Unsupported thumbnail format: {}", format),
        })
    }
}

#[derive(PartialEq, Debug, Copy, Clone, Hash)]
pub enum DataType {
    None,
    /// 8bit per channel RGB pixmap
    Pixmap8Rgb,
    /// 16bit per channel RGB pixmap
    Pixmap16Rgb,
    /// JPEG data
    Jpeg,
    /// TIFF container
    Tiff,
    /// PNG container
    Png,
    /// RAW container
    Raw,
    /// Compressed RAW container
    CompressedRaw,
    /// Unknown format
    Unknown,
    /// Other raw FFI type not covered by this enum
    ///
    /// (If you encounter this, please report a bug against this library.)
    Other(ffi::or_data_type::Type),
}

impl fmt::Display for DataType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::None => write!(f, "None"),
            Self::Pixmap8Rgb => write!(f, "8-Bit RGB Pixmap"),
            Self::Pixmap16Rgb => write!(f, "16-Bit RGB Pixmap"),
            Self::Jpeg => write!(f, "JPEG data"),
            Self::Tiff => write!(f, "TIFF container"),
            Self::Png => write!(f, "PNG container"),
            Self::Raw => write!(f, "RAW container"),
            Self::CompressedRaw => write!(f, "Compressed RAW container"),
            Self::Unknown => write!(f, "Unknown"),
            Self::Other(t) => write!(f, "Other({})", t),
        }
    }
}

/// Convert a raw FFI data type to the `DataType` enum.
impl From<ffi::or_data_type::Type> for DataType {
    fn from(dt: ffi::or_data_type::Type) -> Self {
        match dt {
            ffi::or_data_type::OR_DATA_TYPE_NONE => Self::None,
            ffi::or_data_type::OR_DATA_TYPE_PIXMAP_8RGB => Self::Pixmap8Rgb,
            ffi::or_data_type::OR_DATA_TYPE_PIXMAP_16RGB => Self::Pixmap16Rgb,
            ffi::or_data_type::OR_DATA_TYPE_JPEG => Self::Jpeg,
            ffi::or_data_type::OR_DATA_TYPE_TIFF => Self::Tiff,
            ffi::or_data_type::OR_DATA_TYPE_PNG => Self::Png,
            ffi::or_data_type::OR_DATA_TYPE_RAW => Self::Raw,
            ffi::or_data_type::OR_DATA_TYPE_COMPRESSED_RAW => Self::CompressedRaw,
            ffi::or_data_type::OR_DATA_TYPE_UNKNOWN => Self::Unknown,
            other => Self::Other(other),
        }
    }
}

impl TryInto<image::ImageFormat> for DataType {
    type Error = anyhow::Error;

    /// Convert the data type to the corresponding image-rs `ImageFormat`.
    ///
    /// This is only supported for JPEG/PNG/TIFF formats.
    fn try_into(self) -> Result<image::ImageFormat> {
        Ok(match self {
            Self::Jpeg => image::ImageFormat::Jpeg,
            Self::Png => image::ImageFormat::Png,
            Self::Tiff => image::ImageFormat::Tiff,
            other => bail!("Unsupported image format: {}", other),
        })
    }
}
